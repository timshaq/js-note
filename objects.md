# Объекты
## Введение
### Обращение к свойства
```
const obj = {
    name: 'Timur',
    surname: 'Shakirov',
    age: '23',
    "favorite code editor": 'VSCode',
};

obj.name; // Timur
obj["favorite code editor"]; // VSCode

const key = 'surname';

obj[key]; // Shkirov
```

### Удаление свойства
```
delete user.age // удалить свойство объекта
```

### Свойство из переменной с таким же названием
```
function makeUser(name, age) {
  return {
    name: name,
    age: age,
  };
}
function makeUserShort(name, age) {
  return {
    name,
    age,
  };
}
```

### Ограничений на имена свойств нет (в отличии от переменных)
```
let obj = {
  for: 1,
  let: 2,
  return: 3
};
```

### Все ключи свойств в объекте — строки
```
let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

alert( obj["0"] ); // Тест

alert( obj[0] ); // Тест
```

### Оператор in для проверки существования свойства в объекте
```
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```

### Цикл for...in

```
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```

### Упорядочение свойств
Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания

```
let codes = {
  "49": "Германия",
  "41": "Швейцария",
  "44": "Великобритания",
  // ..,
  "1": "США"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```

решением будет добавить +, чтобы свойства стали не целочисленными
```
let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
```
***
## Копирование объектов и ссылки
Примитивные типы присваиваются и копируются «по значению».

Объекты хранятся и копируются «по ссылке».
### Пример изменения по ссылке

```
let user = { name: 'Иван' };

let admin = user;

admin.name = 'Петя';

alert(user.name);
```

### Сравнение по ссылке
Операторы равенства == и строгого равенства === для объектов работают одинаково

> Два объекта равны только в том случае, если это один и тот же объект.

```
let a = {};
let b = a;

alert( a == b );

alert( a === b ); // true
```

```
let a = {};
let b = {};

alert( a == b ); // false
```

### Клонирование объектов
Синтаксис:
```
Object.assign(dest, [src1, src2, src3...])
```
+ Первый аргумент dest — целевой объект.
+ Остальные аргументы src1, ..., srcN являются исходными объектами
+ Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest.
+ Возвращает объект dest.

### Вложенное клонирование

```
let user = {
  name: "Иван",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, один и тот же объект

// user и clone обращаются к одному sizes
user.sizes.width++;       // меняем свойство в одном объекте
alert(clone.sizes.width); // 51, видим результат в другом объекте
```
Мы можем реализовать глубокое клонирование, используя рекурсию.

> Костыльный лайфхак: клонирование с глубоким вложением

```
JSON.parse(JSON.stringify(obj));
```

***
## Сборка мусора
### Достижимость

01. Существует базовое множество достижимых значений (корни), которые не могут быть удалены:
    + Локальные переменные и параметры текущей функции.
    + Переменные и параметры других функций в текущей цепочке вложенных вызовов.
    + Глобальные переменные.
    + (некоторые другие внутренние значения)
01. Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

### Вкратце
Если значение перестало быть достижимым (на него никто не ссылается) сборщик мусора находит его и удаляет.

***
## Методы объекта, "this"

```
let user = {
  name: "Джон",
  age: 30
};

user.sayHi = function() {
  alert("Привет!");
};

user.sayHi(); // Привет!
```
сокращенная запись:
```
user.sayHi() {
  alert("Привет!");
};
```

### this в методах

```
let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
```

если вызвать без объекта
```
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```
+ В строгом режиме ("use strict") в таком коде значением this будет являться undefined. Если мы попытаемся получить доступ к name, используя this["name"] – это вызовет ошибку.
+ В нестрогом режиме this будет глобальный объект. Это – исторически сложившееся поведение this, которое исправляется использованием строгого режима.

### У стрелочных функций нет this

***
## Конструкторы, создание объектов через "new"
### Функция конструктор
```
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // false
```
> Если конструктор не принимает аргументы, можно вызывать его без скобок
```
let user = new User;
```

### Функция конструктор с return
return с объектом возвращает объект, в любом другом случае конструктор вернёт this
```
function BigUser() {

  this.name = "Вася";

  return { name: "Godzilla" };  // <-- возвращает этот объект
}

alert( new BigUser().name );  // Godzilla, получили этот объект
```
```
function SmallUser() {

  this.name = "Вася";

  return; // <-- возвращает this
}

alert( new SmallUser().name );  // Вася
```

### Методы в конструкторе
```
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася
```

